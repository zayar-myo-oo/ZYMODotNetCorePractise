!function (a) { let e = { messageNoSupport: "グラフを表示するには、canvasタグをサポートしたブラウザが必要です。", namespace: "bubble_", img: [], imgSize: { min: 30, max: 80 }, imgs: !1, bubbles: !1, shadowColor: ["#F00", "#0F0"], shadowBlur: 1, granularity: .01, bubbleFunc: !1, radiusFunc: !1, angleFunc: !1, velocityFunc: !1, animate: !0 }, l = { id: "#", class: "." }; a.fn.bubble = function (i) { let s = {}, n = this, u = n.length; if (0 === u) return this; if (u > 1) return n.each(function () { a(this).bubble(i) }), this; let r, c, o, t = [], d = [], g = () => { u = b = $ = h = y = F = v = x = f = m = g = void 0 }, b = () => { s = a.extend({}, e, i), y(a => { F(), v(), x(), f(a), _(), g() }) }, m = () => Math.random(), $ = (a, e) => Math.floor(Math.random() * (e + 1 - a)) + a, h = a => a[Math.floor(Math.random() * a.length)], y = e => { let l = [], i = s.img.length; 0 === i && e(l); let n = 0; for (var u = 0; u < i; ++u)l[u] = a("<img>"), l[u].on("load error", () => { i === ++n && e(l) }), l[u].attr("src", s.img[u]) }, F = () => { n.append('				<canvas class="' + s.namespace + 'canvas">					' + s.messageNoSupport + "				</canvas>			"); let e = a(l.class + s.namespace + "canvas", n); c = n.width(), o = n.height(), e.attr({ width: c, height: o }) }, v = () => { !1 === s.bubbles && (s.bubbles = Math.floor(s.granularity * (c + o))), !1 === s.imgs && (s.imgs = Math.floor(s.granularity * (c + o))), !1 === s.bubbleFunc && (s.bubbleFunc = () => "hsla(0, 0%, 100%, " + .1 * m() + ")"), !1 === s.radiusFunc && (s.radiusFunc = () => m() * c / 30), !1 === s.angleFunc && (s.angleFunc = () => m() * Math.PI * 2), !1 === s.velocityFunc && (s.velocityFunc = () => m()) }, x = () => { let e = a(l.class + s.namespace + "canvas", n); (r = e.get(0).getContext("2d")).shadowBlur = s.shadowBlur }, f = a => { for (var e = 0, l = s.bubbles; e < l; ++e)t.push({ bubbleFunc: s.bubbleFunc.call(), shadowColor: h(s.shadowColor), x: m() * c, y: m() * o, radius: s.radiusFunc.call(), angle: s.angleFunc.call(), velocity: s.velocityFunc.call() }); if (a.length) for (var e = 0, l = s.imgs; e < l; ++e)d.push({ eleImg: h(a), x: m() * c, y: m() * o, size: $(s.imgSize.min, s.imgSize.max), radius: s.radiusFunc.call(), angle: s.angleFunc.call(), velocity: s.velocityFunc.call() }) }, _ = e => { r.clearRect(0, 0, c, o), t.forEach(a => { r.beginPath(), r.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), r.shadowColor = a.shadowColor, r.fillStyle = a.bubbleFunc, r.fill(), a.x += Math.cos(a.angle) * a.velocity, a.y += Math.sin(a.angle) * a.velocity, a.x - a.radius > c && (a.x = -a.radius), a.x + a.radius < 0 && (a.x = c + a.radius), a.y - a.radius > o && (a.y = -a.radius), a.y + a.radius < 0 && (a.y = o + a.radius) }), d.forEach(e => { size = s.imgMaxSize, r.drawImage(a(e.eleImg).get(0), e.x, e.y, e.size, e.size), e.x += Math.cos(e.angle) * e.velocity, e.y += Math.sin(e.angle) * e.velocity, e.x - e.radius > c && (e.x = -e.radius), e.x + e.radius < 0 && (e.x = c + e.radius), e.y - e.radius > o && (e.y = -e.radius), e.y + e.radius < 0 && (e.y = o + e.radius) }), s.animate && window.requestAnimationFrame(a => _(a)) }; return b(), this } }(jQuery);